{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function(get) {\n      return get(this);\n    };\n    config.write = function(get, set, arg) {\n      return set(\n        this,\n        typeof arg === \"function\" ? arg(get(this)) : arg\n      );\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const dependencyMap = /* @__PURE__ */ new Map();\n    const dirtyMap = /* @__PURE__ */ new WeakMap();\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const loop1 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        if (dependent !== a) {\n          dependencyMap.set(\n            dependent,\n            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)\n          );\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom);\n    const loop2 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent, true);\n              isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach((s) => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom);\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n", "'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": "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",
  "names": ["atom", "isPromiseLike", "ReactExports", "atom"]
}
